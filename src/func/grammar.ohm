FunC {
  Module = ModuleItem*

  //
  // Top-level, module items (with compiler directives)
  //

  ModuleItem = Pragma
             | Include
             | GlobalVariablesDeclaration
             | ConstantsDefinition
             | AsmFunctionDefinition
             | FunctionDeclaration
             | FunctionDefinition

  //
  // Compiler pragmas and includes
  //

  Pragma = "#pragma" ("allow-post-modification" | "compute-asm-ltr") ";" --literal
         | "#pragma" ("version" | "not-version") versionRange ";" --versionRange
         | "#pragma" "test-version-set" stringLiteral ";" --versionString

  Include = "#include" stringLiteral ";"

  //
  // Declarations of global variables
  //

  GlobalVariablesDeclaration = "global" NonemptyListOf<GlobalVariableDeclaration, ","> ";"
  GlobalVariableDeclaration = TypeGlob? id

  TypeGlob = TypeBuiltinGlob ("->" TypeGlob)?

  TypeBuiltinGlob = #("int" | "cell" | "slice" | "builder" | "cont" | "tuple" | hole) ~#rawId --simple
                  | unit | tupleEmpty | TensorGlob | TupleGlob

  TensorGlob = "(" NonemptyListOf<TypeGlob, ","> ")"
  TupleGlob = "[" NonemptyListOf<TypeGlob, ","> "]"

  //
  // Definitions of constants
  //

  ConstantsDefinition = "const" NonemptyListOf<ConstantDefinition, ","> ";"
  ConstantDefinition = ("slice" | "int")? id "=" Expression

  //
  // Definitions of asm functions
  //

  AsmFunctionDefinition = FunctionCommonPrefix "asm" AsmArrangement? stringLiteral+ ";"

  AsmArrangement = "(" "->" &#whiteSpace integerLiteralDec+ ")" --returns
                 | "(" id+ ~"->" ")" --arguments
                 | "(" id+ &#whiteSpace "->" &#whiteSpace integerLiteralDec+ ")" --argumentsToReturns

  //
  // Function declarations, definitions and common prefix of their syntax
  //

  FunctionDeclaration = FunctionCommonPrefix ";"
  FunctionDefinition = FunctionCommonPrefix "{" Statement* "}"

  // (not a separate thing, added purely for convenience)
  FunctionCommonPrefix = Forall? TypeReturn functionId Parameters FunctionAttribute*

  // forall type1, ..., typeN ->
  Forall = "forall" &#whiteSpace NonemptyListOf<TypeVar, ","> &#whiteSpace "->" &#whiteSpace
  TypeVar = ("type" &#whiteSpace)? id

  // Function return types
  TypeReturn = TypeBuiltinReturn (&#whiteSpace "->" &#whiteSpace TypeReturn)?

  TypeBuiltinReturn = id
                    | "int" | "cell" | "slice" | "builder" | "cont" | "tuple"
                    | "_" | unit | tupleEmpty | TensorReturn | TupleReturn

  TensorReturn = "(" NonemptyListOf<TypeReturn, ","> ")"
  TupleReturn = "[" NonemptyListOf<TypeReturn, ","> "]"

  // Function parameters (upper is defined in Ohm's built-in rules)
  Parameters = "(" ListOf<Parameter, ","> ")"
  Parameter = TypeParameter (unusedId | functionId)? --regular
            | functionId --inferredType
            | "_" --hole

  // Function parameter types
  TypeParameter = TypeBuiltinParameter (&#whiteSpace "->" &#whiteSpace TypeParameter)?

  TypeBuiltinParameter = upperId
                       | "int" | "cell" | "slice" | "builder" | "cont" | "tuple"
                       | hole | unit | tupleEmpty | TensorParameter | TupleParameter

  TensorParameter = "(" NonemptyListOf<TypeParameter, ","> ")"
  TupleParameter = "[" NonemptyListOf<TypeParameter, ","> "]"

  // Called "specifiers" in https://docs.ton.org/develop/func/functions#specifiers
  FunctionAttribute = "impure" | "inline_ref" | "inline" | MethodIdValue | "method_id"
  MethodIdValue = "method_id" "(" integerLiteral ")" --int
                | "method_id" "(" stringLiteral ")" --string

  //
  // Statements (with mandatory whitespace padding in most places)
  //

  Statement = StatementReturn
            | StatementBlock
            | StatementEmpty
            | StatementCondition
            | StatementRepeat
            | StatementUntil
            | StatementWhile
            | StatementTryCatch
            | StatementExpression

  StatementReturn = "return" Expression ";"

  StatementBlock = "{" Statement* "}"

  StatementEmpty =  ";"

  StatementCondition = ("ifnot" | "if") Expression "{" Statement* "}"
                       ("elseifnot" | "elseif") Expression "{" Statement* "}"
                       ElseBlock? --elseif
                     | ("ifnot" | "if") Expression "{" Statement* "}"
                       ElseBlock? --if

  // (not a separate statement, added purely for convenience)
  ElseBlock = "else" "{" Statement* "}"

  StatementRepeat = "repeat" Expression  "{" Statement* "}"

  StatementUntil = "do" "{" Statement* "}" "until" Expression ";"

  StatementWhile = "while" Expression "{" Statement* "}"

  StatementTryCatch = "try"
                      "{" Statement* "}"
                      "catch" "(" CatchClauseContents ")"
                      "{" Statement* "}"

  // (not a separate thing, added purely for convenience)
  CatchClauseContents = (unusedId | id) "," (unusedId | id) --both
                      | unusedId --unused

  StatementExpression = Expression ";"

  //
  // Expressions, ordered by precedence (from lowest to highest),
  // with comments referencing exact function names in C++ code of FunC's parser:
  // https://github.com/ton-blockchain/ton/blob/master/crypto/func/parse-func.cpp
  //

  // parse_expr
  Expression = ExpressionAssign

  // parse_expr10
  ExpressionAssign = ExpressionConditional
                     &#whiteSpace ("=" ~#"=" | "+=" | "-=" | "*=" | "/=" | "%="
                          | "~/=" | "~%=" | "^/=" | "^%=" | "&="
                          | "|=" | "^=" | "<<=" | ">>=" | "~>>=" | "^>>=") &#whiteSpace
                     ExpressionAssign --op
                   | ExpressionConditional

  // parse_expr13
  ExpressionConditional = ExpressionCompare
                          &#whiteSpace "?" &#whiteSpace Expression
                          &#whiteSpace ":" &#whiteSpace ExpressionConditional --ternary
                        | ExpressionCompare

  // parse_expr15
  ExpressionCompare = ExpressionBitwiseShift
                      &#whiteSpace ("==" | "<=>" | "<=" | "<" | ">=" | ">" | "!=") &#whiteSpace
                      ExpressionBitwiseShift --op
                    | ExpressionBitwiseShift

  // parse_expr17
  ExpressionBitwiseShift = ExpressionAddBitwise
                           (&#whiteSpace ("<<" | ">>" | "~>>" | "^>>") &#whiteSpace
                            ExpressionAddBitwise)+ --ops
                         | ExpressionAddBitwise

  // parse_expr20
  ExpressionAddBitwise = ("-" &#whiteSpace)?
                         ExpressionMulBitwise
                         (&#whiteSpace ("+" | "-" | "|" | "^") &#whiteSpace
                          ExpressionMulBitwise)+ --ops
                       | "-" &#whiteSpace ExpressionMulBitwise --negate
                       | ExpressionMulBitwise

  // parse_expr30
  ExpressionMulBitwise = ExpressionUnary
                         (&#whiteSpace ("*" | "/%" | "/" | "%"
                            | "~/" | "~%" | "^/" | "^%" | "&") &#whiteSpace
                          ExpressionUnary)+ --ops
                       | ExpressionUnary

  // parse_expr75
  ExpressionUnary = "~" &#whiteSpace ExpressionMethod --bitwiseNot
                  | ExpressionMethod

  // parse_expr80
  ExpressionMethod = ExpressionVarFun (methodId &("(" | "[" | functionId) ExpressionArgument)+ --calls
                   | ExpressionVarFun

  // parse_expr90
  ExpressionVarFun = | ExpressionVarDecl | ExpressionFunCall | ExpressionPrimary

  // Variable declarations
  ExpressionVarDecl = TypeVarDecl ExpressionVarDeclPart

  // (not a separate expression, added purely for convenience)
  ExpressionVarDeclPart = id
                        | unusedId
                        | ExpressionTensorVarDecl
                        | ExpressionTupleVarDecl

  ExpressionTensorVarDecl = "(" NonemptyListOf<IdOrUnusedId, ","> ")"
  ExpressionTupleVarDecl = "[" NonemptyListOf<IdOrUnusedId, ","> "]"
  // (not a separate expression, added purely for convenience)
  IdOrUnusedId = id | unusedId

  // Function calls
  ExpressionFunCall = &("(" | functionId) ExpressionPrimary ExpressionArgument+

  // (not a separate expression, added purely for convenience)
  ExpressionArgument = functionId
                     | unit
                     | ExpressionTensor
                     | tupleEmpty
                     | ExpressionTuple

  // parse_expr100
  ExpressionPrimary = unit
                    | ExpressionTensor
                    | tupleEmpty
                    | ExpressionTuple
                    | integerLiteral
                    | stringLiteral
                    | functionId
                    | unusedId

  ExpressionTensor = "(" ListOf<Expression, ","> ")"
  ExpressionTuple = "[" ListOf<Expression, ","> "]"

  // Variable declaration types
  TypeVarDecl = TypeBuiltinVarDecl (&#whiteSpace "->" &#whiteSpace TypeVarDecl)?

  TypeBuiltinVarDecl = #("int" | "cell" | "slice" | "builder" | "cont" | "tuple" | hole) ~#rawId --simple
                     | unit | tupleEmpty | TensorVarDecl | TupleVarDecl
  // TODO: return `| id`, differentiate between function calls and variable declarations during syntax analysis and AST construction (through careful use of declared type variables in `forall`)
  // NOTE: this can be easily added using the same heuristic as in parameters -- upperId, because type variables are advised to be named starting with an uppercase letter.

  TensorVarDecl = "(" NonemptyListOf<TypeVarDecl, ","> ")"
  TupleVarDecl = "[" NonemptyListOf<TypeVarDecl, ","> "]"

  //
  // Lexical rules, see: https://ohmjs.org/docs/syntax-reference#syntactic-lexical
  //

  // Special types or values
  hole = ("_" | "var") ~rawId
  unit = "(" whiteSpace* ")"
  // (not a separate type, added purely for convenience)
  tupleEmpty = "[" whiteSpace* "]"
  primitive = "int" | "cell" | "slice" | "builder" | "cont" | "tuple"

  // Operators and delimiters, order matters
  operator = "!=" | "?" | ":"
           | "%=" | "%"
           | "&=" | "&"
           | "*=" | "*"
           | "+=" | "+"
           | "-=" | "-"
           | "/%" | "/=" | "/"
           | "<=>"
           | "<<=" | "<<" | "<=" | "<"
           | "==" | "="
           | ">>=" | ">>" | ">=" | ">"
           | "^>>=" | "^>>" | "^=" | "^/=" | "^/" | "^%=" | "^%" | "^"
           | "|=" | "|"
           | "~>>=" | "~>>" | "~/=" | "~/" | "~%" | "~"
  delimiter = "->" | "{" | "}"

  // Function identifiers
  functionId = ~("\"" | "{-") ("." | "~")? ~((hole | integerLiteral | delimiter | operator | primitive) ~rawId) rawId

  // Method identifiers (not a separate type, added purely for convenience)
  methodId = ~("\"" | "{-") ("." | "~") ~((hole | integerLiteral | delimiter | operator | primitive) ~rawId) rawId

  // Uppercase plain identifiers (common for type variables)
  upperId = &upper plainId

  // Identifiers, with invalidation (keywords, numbers, etc.) during syntax analysis
  // — this makes this parser closer to the C++ one, and also improves error messages
  id = ~("\"" | "{-" | "." | "~") ~((hole | integerLiteral | delimiter | operator | primitive) ~rawId) rawId

  // Contents of any identifiers
  rawId = quotedId | operatorId | plainId

  // Kinds
  quotedId = "`" (~("`" | "\n") any)+ "`"
  operatorId = "^"? "_" operator "_" --common
             | "~_" --not
  plainId = (~(whiteSpace | "(" | ")" | "[" | "]" | "," | "." | ";" | "~") any)+

  // Unused identifiers
  unusedId = "_"

  /*
    FunC can parse much more than Fift can handle. For example, _0x0 and _0 are valid identifiers in FunC, and using either of them compiles and is then interpreted fine by Fift. But if you use both, FunC still compiles, but Fift crashes.

    Same goes for plain identifiers using hashes # or emojis — you can have one FunC function with any of those combinations of characters, but you (generally) cannot have two or more of such functions.
  */

  // Version ranges
  versionRange = ("=" | "^" | "<=" | ">=" | "<" | ">")? integerLiteralDec ("." integerLiteralDec)? ("." integerLiteralDec)?

  // Integers
  integerLiteral = "-"? integerLiteralNonNegative
  integerLiteralNonNegative = integerLiteralHex | integerLiteralDec

  // hexDigit is defined in Ohm's built-in rules as: hexDigit = "0".."9" | "a".."f" | "A".."F"
  integerLiteralHex = "0x" hexDigit+

  // digit is defined in Ohm's built-in rules as: digit = "0".."9"
  integerLiteralDec = digit+

  // Strings
  stringLiteral = "\"\"\"" (~"\"\"\"" any)* "\"\"\"" stringType? --multiLine
                | "\"" (~"\"" any)* "\"" stringType? --singleLine

  stringType = "s" --sliceHex
             | "a" --sliceInternalAddress
             | "u" --intHex
             | "h" --int32Sha256
             | "H" --int256Sha256
             | "c" --intCrc32

  // Whitespace
  space += comment | lineTerminator
  whiteSpace = "\t" | " " | lineTerminator

  // Comments
  comment = ";;" (~lineTerminator any)* --singleLine
          | multiLineComment --multiLine

  // Nested multi-line comments
  multiLineComment = "{-" (~("-}" | "{-") any)* multiLineComment? (~"-}" any)* "-}"

  lineTerminator = "\n" | "\r" | "\u2028" | "\u2029"
}
